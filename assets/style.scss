// ora che la toolchain è pronta
// (scss -> css -> link in HTML -> live server)
// possiamo esplorare tutte le caratteristiche di SASS
// 1) SASS è 100% RETROCOMPATIBILE CON CSS
// i commenti in SCSS si fanno come in JS
// proviamo ad azzerare i margini sul body
body,
h1 {
  margin: 0;
}

// 2) SELETTORI ANNIDATI / NIDIFICATI (nested)
// nav {
//   display: block;
//   width: 100%;
// }

// nav ul {
//   display: flex;
//   flex-direction: column;
//   margin: 0;
//   padding: 0;
//   list-style-type: none;
//   text-align: center;
// }

// nav ul li {
//   font-family: Arial, Helvetica, sans-serif;
// }

// nav ul li a {
//   color: black;
//   text-decoration: none;
// }

nav {
  display: block;
  width: 100%;
  ul {
    // -> nav ul
    display: flex;
    flex-direction: column;
    margin: 0;
    padding: 0;
    list-style-type: none;
    text-align: center;
    li {
      // --> nav ul li
      font-family: Arial, Helvetica, sans-serif;
      a {
        color: black;
        text-decoration: none;
      }
    }
  }
}

// 3) PSEUDOCLASSI IN SASS (es. hover, active, etc.)

// .primary {
//   background-color: purple;
//   color: white;
//   padding: 0.5em 1em;
//   border-radius: 20px;
// }

// .primary:hover {
//   background-color: white;
//   color: purple;
// }

.primary {
  background-color: purple;
  color: white;
  padding: 0.5em 1em;
  border-radius: 20px;
  &:hover {
    // & vuole dire "selettore corrente", .primary
    background-color: white;
    color: purple;
  }
}

// 4) PREFISSI COMUNI PER PROPRIETÀ SIMILI
// p.pacchiano {
//   font-size: 1.2em;
//   font-weight: bold;
//   font-style: italic;
//   font-family: Arial, Helvetica, sans-serif;
// }

p.pacchiano {
  font: {
    size: 1.2em;
    weight: bold;
    style: italic;
    family: Arial, Helvetica, sans-serif;
  }

  border: {
    width: 2px;
    style: dashed;
    color: black;
    radius: 20px;
  }
}

// ---- finite le semplici migliorie stilistiche
// cominciano con la sezione FUNZIONALITÀ

// 5) VARIABILI
// Le variabili in SASS sono dei contenitori per memorizzare valori.
// In SASS le variabili si associano a livello di significato più alle COSTANTI (è raro
// che una variabile SASS cambi valore).

// quali sono i TIPI DI DATO in SASS?
// - valori numerici (0, 100, 10px, 2em, 1rem etc.)
// - stringhe ('2px solid black', '0 auto', etc.)
// - colori (red, #b9b9b9, rgb(10, 200, 50), hsl(233, 81.8%, 43.1%))
// - booleani (true, false)
// - null
// - LISTE (10px, 16px, 24px) -> un po' come gli ARRAY in JS
// - MAPPE di coppie chiave:valore -> un po' come gli OGGETTI in JS

// come si dichiara una VARIABILE in SASS?
// in JS si segue la nomenclatura camelCase -> nomeVariabile
// in SASS si segue la nomenclatura kebab-case -> nome-variabile

$my-color: green;
$main-margin: 1.2em;
$special-border: 3px dotted red;

p.colored {
  color: $my-color;
  border: $special-border;
}

p.another {
  background-color: $my-color;
}

// 6) MIXIN
// un "mixin" in SASS è un BLOCCO di regole/proprietà CSS a cui date un nome

@mixin centered {
  display: flex;
  justify-content: center;
  align-items: center;
}

@mixin bordered {
  border: $special-border;
  border-radius: 20px;
}

#img-container {
  margin-left: $main-margin;
  margin-right: $main-margin;
  @include bordered;
  @include centered;
}

// ...quindi un mixin ricorda vagamente come concetto quello di una "funzione" in JS:
// in un colpo solo riporta molteplici regole CSS
// e, come in JS, anche in SASS i mixin possono accettare PARAMETRI

@mixin custom-bordered($radius: 20px) {
  border: $special-border;
  border-radius: $radius;
}

.big-border {
  @include custom-bordered(30px);
}

.small-border {
  @include custom-bordered(10px);
}

.unknown-border {
  @include custom-bordered; // prenderà in automatico 20px come valore di default
}

// 7) INTERPOLAZIONE DI STRINGHE & VALORI

// in JS...
// const a = 'size'
// const name = 'font-' + a // 'font-size'
// const name2 = `font-${a}` // 'font-size'

// in SASS...
$a: 'size';
.test {
  font-#{$a}: 16px; // font-size: 16px
}

// 8) C  I  C  L  I
// in SASS è possibile utilizzare i CICLI per AUTOMATIZZARE la creazione di stili "in serie"

// creiamo una LISTA
$sizes: 12px, 16px, 20px, 24px;
// const sizes: ['12px', '16px', ecc.]

// il mio scopo è creare 4 classi CSS in cui in ognuna sarà presente una font-size
// con un valore diverso (tipo i fs-1, fs-2, fs-3 etc. di bootstrap)

// in JS forEach è un metodo degli array che cicla l'array e vi espone di volta in volta
// uno degli elementi, a cui potete dare un nome (il nome del parametro, io ho scelto "size")
// sizes.forEach(size => {})

// in SASS la sintassi è simile, $size è il nome del singolo elemento di $sizes e l'ho
// inventato io
@each $size in $sizes {
  // alla prima iterazione del ciclo, $size vale 12px
  // alla seconda iterazione del ciclo, $size vale 16px
  // alla terza iterazione del ciclo, $size vale 20px
  // alla quarta iterazione del ciclo, $size vale 24px
  .text-#{$size} {
    font-size: $size;
  }
}

// però così facendo creiamo classi chiamate ".text-12px", che vanno bene ma non sono il massimo
// come creiamo ad esempio un ".text-sm", ".text-md" etc.?
// al momento siamo limitati dal fatto che stiamo ciclando una LISTA (un array)...
// ...proviamo a ciclare UNA MAPPA (un oggetto)!

$sizes-map: (
  sm: 12px,
  md: 16px,
  xl: 20px,
  xxl: 24px,
);

@each $name, $value in $sizes-map {
  // $name vale sm, md, xl, xxl
  // $value vale 12px, 16px, 20px, 24px

  .text-#{$name} {
    font-size: $value;
  }
}
